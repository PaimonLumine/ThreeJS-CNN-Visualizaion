<!--主文件-->
<!DOCTYPE html>
<html lang="en">

<head>
    <title>3D Visualization of a Convolutional Neural Network</title>
    <link rel="stylesheet" href="css/drawingboard2.css">
    <link rel="stylesheet" href="css/main5.css">
    <link rel="stylesheet" type="text/css" href="css/katex.min.css">

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

    <script src="js/three.min.js"></script>
    <script src="js/math.min.js"></script>
    <script src="js/jquery-1.11.2.min.js"></script>
    <script src="js/sylvester.src.js"></script>
    <script src="js/GeometryUtils.js"></script>
    <script src="js/processing.min.js"></script>
    <!--加载画板-->
    <script src="js/drawingboard/utils.js"></script>
    <script src="js/drawingboard/board.js"></script>
    <script src="js/drawingboard/controls/control.js"></script>
    <script src="js/drawingboard/controls/color.js"></script>
    <script src="js/drawingboard/controls/drawingmode.js"></script>
    <script src="js/drawingboard/controls/navigation.js"></script>
    <script src="js/drawingboard/controls/size.js"></script>
    <script src="js/drawingboard/controls/download.js"></script>
    <!--加载神经网络模型-->
    <script src="js/nn/convnet.js"></script>
    <script src="js/nn/nn_funcs_merge4.js"></script>
    <script src="js/createText_func.js"></script>

    <script src="css/fonts/droid_sans_regular.typeface.js"></script>
    <script src="js/colormaps/myColorMap_dark.js"></script>

    <script src="js/controls/myOrbitControls.js"></script>
    <script src="js/stats.min.js"></script>

    <link rel="stylesheet" type="text/css" href="css/katex.min.css">
    <script type="text/javascript" src="js/katex.min.js"></script>
    <!--加载调色板-->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/spectrum/1.8.0/spectrum.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/spectrum/1.8.0/i18n/jquery.spectrum-ja.min.js"></script>
    <link rel="stylesheet" type="text/css"
        href="https://cdnjs.cloudflare.com/ajax/libs/spectrum/1.8.0/spectrum.min.css">

    <style>     
        #bodyDesign {
            font-family: Arial;
            background-color: #ffffff;
            background: radial-gradient(ellipse at center, rgb(0, 123, 247) 0%, rgb(255, 255, 255) 100%);
            /* W3C */

            margin: 0;
            font-family: Arial;
            overflow: hidden;
        }
    </style>

    <script> /*调色板*/
        jQuery(function ($) {
            $("#picker").spectrum({
                color: "#1205fe", // 初始值
                flat: false, // 如果为 true，则允许选择器出现而不单击
                showInput: true, // 显示代码输入字段
                showAlpha: true, // 显示不透明度选择栏
                disabled: false, // 如果为真，禁用选择器
                showPalette: true, // 显示调色板
                showPaletteOnly: false, // 如果为真，则仅显示调色板
                togglePaletteOnly: false, // 如果为真，则使用按钮切换调色板以外的部分的显示。
                togglePaletteMoreText: "详细", // togglePaletteOnly 为 true（打开）时的按钮名称
                togglePaletteLessText: "缩略", // togglePaletteOnly 为 true 时的按钮名称（关闭）
                showSelectionPalette: true, // 在调色板中显示用户先前选择的颜色
                maxSelectionSize: 10, // 记忆所选颜色的最大数量
                hideAfterPaletteSelect: false, // 如果为 true，则在选择调色板时关闭选择器
                clickoutFiresChange: true, // 当您在选择器外部单击并关闭选择器时引发更改事件
                showInitial: true, // 显示一个区域以将初始颜色与选定颜色进行比较
                allowEmpty: true, // 允许“未指定”
                chooseText: "OK", // 选择按钮文本
                cancelText: "Cancel", // 取消按钮文本
                showButtons: false, // 显示按钮
                containerClassName: "full-spectrum", // 包含选取器部分的标签（元素）的类名
                replacerClassName: "", // 显示选择器的按钮的类名
                preferredFormat: "hsl", // 将色码格式改成指定的（hex、hex3等）
                localStorageKey: "spectrum.demo", // 用于将所选颜色存储在 localStorage 中的键
                palette: [ // 调色板
                    ["rgb(0, 0, 0)", "rgb(67, 67, 67)", "rgb(102, 102, 102)",
                        "rgb(204, 204, 204)", "rgb(217, 217, 217)", "rgb(255, 255, 255)"],
                    ["rgb(152, 0, 0)", "rgb(255, 0, 0)", "rgb(255, 153, 0)", "rgb(255, 255, 0)", "rgb(0, 255, 0)",
                        "rgb(0, 255, 255)", "rgb(74, 134, 232)", "rgb(0, 0, 255)", "rgb(153, 0, 255)", "rgb(255, 0, 255)"],
                    ["rgb(230, 184, 175)", "rgb(244, 204, 204)", "rgb(252, 229, 205)", "rgb(255, 242, 204)", "rgb(217, 234, 211)",
                        "rgb(208, 224, 227)", "rgb(201, 218, 248)", "rgb(207, 226, 243)", "rgb(217, 210, 233)", "rgb(234, 209, 220)",
                        "rgb(221, 126, 107)", "rgb(234, 153, 153)", "rgb(249, 203, 156)", "rgb(255, 229, 153)", "rgb(182, 215, 168)",
                        "rgb(162, 196, 201)", "rgb(164, 194, 244)", "rgb(159, 197, 232)", "rgb(180, 167, 214)", "rgb(213, 166, 189)",
                        "rgb(204, 65, 37)", "rgb(224, 102, 102)", "rgb(246, 178, 107)", "rgb(255, 217, 102)", "rgb(147, 196, 125)",
                        "rgb(118, 165, 175)", "rgb(109, 158, 235)", "rgb(111, 168, 220)", "rgb(142, 124, 195)", "rgb(194, 123, 160)",
                        "rgb(166, 28, 0)", "rgb(204, 0, 0)", "rgb(230, 145, 56)", "rgb(241, 194, 50)", "rgb(106, 168, 79)",
                        "rgb(69, 129, 142)", "rgb(60, 120, 216)", "rgb(61, 133, 198)", "rgb(103, 78, 167)", "rgb(166, 77, 121)",
                        "rgb(91, 15, 0)", "rgb(102, 0, 0)", "rgb(120, 63, 4)", "rgb(127, 96, 0)", "rgb(39, 78, 19)",
                        "rgb(12, 52, 61)", "rgb(28, 69, 135)", "rgb(7, 55, 99)", "rgb(32, 18, 77)", "rgb(76, 17, 48)"]
                ],
                selectionPalette: [], 

                // 值改变时的事件（确认）
                change: function (color) {
                    $("#bodyDesign").css(
                        "background", 
                        "radial-gradient(ellipse at center, " + color + ", rgb(255, 255, 255)) 100%");
                },
                // 值变化时的事件（未确认）
                move: function (color) {
                    $("#bodyDesign").css(
                        "background", 
                        "radial-gradient(ellipse at center, " + color + ", rgb(255, 255, 255)) 100%");
                        //console.log(color);
                    window.savedcolor = color.getOriginalInput().h;
                    window.savedcolor2 = color.getOriginalInput().s;
                    //console.log(savedcolor);
                    //console.log(window.savedcolor2);
                    savedcolor = savedcolor.slice( 0 , -1);//去掉百分号
                    savedcolor2 = savedcolor.slice( 0 , -1);
                    //console.log(savedcolor);
                    //console.log(typeof savedcolor2);
                    savedcolor = parseFloat(savedcolor);
                    savedcolor = parseInt(savedcolor *3.6);
                    savedcolor = (savedcolor + 270) % 360;
                    savedcolor = savedcolor / 360;
                    savedcolor2 = savedcolor2 / 100;
                    if (savedcolor == NaN) {
                        savedcolor = 0.9;
                    } 
                    if (savedcolor > 1) {
                        savedcolor  = 0.9;
                    }
                    if (savedcolor2 == "") {
                        savedcolor2 = 0.5;
                    }
                    //console.log(savedcolor2);
                    if (savedcolor2 <= 0.5) {
                        savedcolor2 = 0.5;
                    }
                },
                // 选择器关闭时的事件
                hide: function (color) {
                },
                // 选择器显示事件
                show: function (color) {
                },
                // 显示选择器之前的事件。 您可以使用 return false 阻止选择器显示
                beforeShow: function (color) {
                },
            });
        });
    </script>

</head>

<body id="bodyDesign">

    <div id="webgl_container">
        <div id="infobox">
            <div id="nodeType"></div>
            <div id="imageInputContainer">
                <div id="inputImage">
                    <div class="label" id="imageLabel">Input image:</div>
                    <div id="inputCanvasContainer">
                        <canvas id="inputCanvas"></canvas>
                    </div>
                </div>
                <div id="filterImage">
                    <div class="label" id="filterLabel">Filter:</div>
                    <div id="filterCanvasContainer">
                        <canvas id="filterCanvas"></canvas>
                    </div>
                </div>
            </div>
            <div id="nodeInputContainer">
                <div class="label">Weighted input: </div>
                <div id="nodeInput" class="math"></div>
            </div>
            <div id="calcContainer">
                <div class="label">Calculation: </div>
                <div id="calc" class="math"></div>
            </div>
            <div id="nodeOutputContainer">
                <div class="label">Output: </div>
                <div id="nodeOutput" class="math"></div>
            </div>
        </div>
    </div>

    <div id="canvasContainer">
        <!--style="visibility: hidden">-->
        <div id="drawingInterface">
            <div class="instructions">Draw your number here</div>
            <div class="board" id="custom-board"></div>
            <div class="drawingOutput">
                <div class="row">
                    <div class="info">Downsampled drawing:</div>
                    <div class="tinyBoard">
                        <canvas id="tiny"></canvas>
                    </div>
                </div>
                <div class="row">
                    <div class="info cell">First guess:</div>
                    <div id="ans1" class="ans cell"></div>
                </div>
                <div class="row cell">
                    <div class="info cell">Second guess:</div>
                    <div id="ans2" class="ans cell"></div>
                </div>
            </div>
        </div>
        <div id="filterInterface">
        <!--调色板-->
        </div>
        <input type="text" id="picker">


    </div>

    <script>
        //主脚本

        var input_hide = false, conv1_hide = false, down1_hide = false, conv2_hide = false, down2_hide = false, fc1_hide = false, fc2_hide = false, output_hide = false;
        var input_was_hidden = false, conv1_was_hidden = false, down1_was_hidden = false, conv2_was_hidden = false, down2_was_hidden = false, fc1_was_hidden = false, fc2_was_hidden = false, output_was_hidden = false;

        var rotatingCam = false;


        var container, stats, gl;
        var camera, controls, scene, renderer;
        var pickingData = [], pickingTexture, pickingScene;
        var objects = [];
        var highlightBox;
        var allZeroes = true;

        var nPixels = 32 * 32;
        var nConvNodes_1 = 28 * 28 * 6;
        var nConvNodes_1_down = 14 * 14 * 6;
        var nConvNodes_2 = 10 * 10 * 16;
        var nConvNodes_2_down = 5 * 5 * 16;
        var filterSize_1 = 5;
        var filterSize_2 = 5;
        var nConvFilters_1 = 6;
        var nConvFilters_2 = 16;
        var nConvLayers = 2;
        var nHiddenNodes_1 = 120;
        var nHiddenNodes_2 = 100;
        var nHiddenLayers = 2;
        var nFinalNodes = 10;
        var nNodes = nPixels + nConvNodes_1 + nConvNodes_1_down + nConvNodes_2 + nConvNodes_2_down + nHiddenNodes_1 + nHiddenNodes_2 + nFinalNodes;
        //console.log('nNodes = ' + nNodes);
        var allNodeNums = new Array(nNodes);
        var allNodeInputs = new Array(nNodes);
        var allNodeOutputs = new Array(nNodes);
        var allNodeOutputsRaw = new Array(nNodes);
        var finalOutputID = 0;
        var isComputed = false;
        var goodStart = false;
        var hidden_weights_1a, hidden_weights_2a, final_weightsa;
        var conv_weights_1a;
        var conv_weights_2a;

        var countdown = 0;
        if (countdown == 0) {
            var savedcolor = 0.36;
            var savedcolor2 = 1;
            countdown++;
        }
        

        var keeperIndices;
        var nKeepers;

        var interID, row, col, ind_below;
        var intersected = false;

        var posX = [], posY = [], posZ = [], layerNum = [];

        var originalWidth = window.innerWidth;
        var originalHeight = window.innerHeight;

        var mouse = new THREE.Vector2();
        var mousepx = new THREE.Vector2();

        var filterNum, filterNum_below;
        var nodeType;
        var inputCanvasContainer = document.getElementById("inputCanvasContainer");
        var filterCanvasContainer = document.getElementById("filterCanvasContainer");
        var inputCanvas = document.getElementById("inputCanvas");
        var filterCanvas = document.getElementById("filterCanvas");
        var inputCtx = inputCanvas.getContext("2d");
        var filterCtx = filterCanvas.getContext("2d");

        //draw numbers from 0 to 9

        var nums = "0 1 2 3 4 5 6 7 8 9",
            height = 1,
            size = 9,
            hover = 260,

            curveSegments = 8,

            bevelThickness = 2,
            bevelSize = 1.5,
            bevelSegments = 3,
            bevelEnabled = false,

            font = "droid sans", // helvetiker, optimer, gentilis, droid sans, droid serif
            weight = "normal", // normal bold
            style = "normal"; // normal italic

        var customBoard = new DrawingBoard.Board('custom-board', {
            background: "#000",
            color: "#fff",
            size: 30,
            controls: [
                { Navigation: { back: false, forward: false } },
                { DrawingMode: { filler: false } }
            ],
            controlsPosition: "bottom right",
            webStorage: 'session',
            droppable: false
        });

        var tinyCtx = $("#tiny")[0].getContext("2d");
        tinyCtx.scale(0.1, 0.1);
        function updateTinyBoard() {//更新小框
            if (goodStart) {

                var imageData = customBoard.getImg();

                var newCanvas = $("<canvas>")
                    .attr("width", imageData.width)
                    .attr("height", imageData.height)[0];

                newCanvas.getContext("2d").putImageData(imageData, 0, 0);
                tinyCtx.drawImage(newCanvas, 0, 0);
                getNNOutput();


            }
        };


        init();
        loadData();
        animate();

        function applyVertexColors(g, c) {
            var count = 0;
            g.faces.forEach(function (f) {

                var n = (f instanceof THREE.Face3) ? 3 : 4;
                for (var j = 0; j < n; j++) {

                    f.vertexColors[j] = c;
                    count++;
                }

            });

        }
        function applySpecialVertexColors(g) {

            var faceCount = 0;
            var color = new THREE.Color();
            color.setHex(Math.random() * 0xffffff)
            var cubeNum = 0;
            g.faces.forEach(function (f) {
                faceCount++;
                cubeNum = faceCount / 12;
                if (faceCount % 12 == 1) {
                    color = new THREE.Color();
                    color.setHex(Math.random() * 0xffffff)
                }
                if (faceCount <= 12) {
                    color = new THREE.Color();
                    color.setHex(0x0000ff)
                }
                var n = (f instanceof THREE.Face3) ? 3 : 4;
                for (var j = 0; j < n; j++) {
                    f.vertexColors[j] = color;
                }
            });
        }


        function init() {//初始化
            container = document.getElementById("webgl_container");



            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 5000);
            camera.position.z = 1000;
            camera.position.y = 200;

            scene = new THREE.Scene();

            pickingScene = new THREE.Scene();
            pickingTexture = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight);
            pickingTexture.minFilter = THREE.LinearFilter;
            pickingTexture.generateMipmaps = false;

            var light = new THREE.SpotLight(0xffffff, 1.0);//光源
            light.name = "light";
            light.position.set(0, 500, 2000);
            scene.add(light);
            var light2 = new THREE.SpotLight(0xffffff, 0.5);
            light2.name = "light";
            light2.position.set(0, 200, -1000);
            scene.add(light2);
            var light3 = new THREE.AmbientLight(0xffffff);
            light3.name = "light";
            scene.add(light3);

            highlightBox = new THREE.Mesh(//高亮方块
                new THREE.BoxGeometry(12, 12, 12),
                new THREE.MeshLambertMaterial({ color: 0xffff00 }
                ));
            highlightBox.visible = false;
            scene.add(highlightBox);


            hideInputBox = new THREE.Mesh( 
                new THREE.BoxGeometry(340, 20, 340),
                new THREE.MeshLambertMaterial({ color: 0x00ff00, transparent: true, opacity: 0.1 }
                ));
            hideInputBox.position.set(0, -250, 0);
            hideInputBox.visible = true;


            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });   //渲染器
            renderer.setClearColor(0x000000, 0);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.sortObjects = false;
            container.appendChild(renderer.domElement);


            var cameraControls;
            cameraControls = new THREE.OrbitControls(camera, renderer.domElement);
            cameraControls.target.set(0, 0, 0);

            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('mousedown', onMouseDown);
            renderer.domElement.addEventListener('click', onClick);
            renderer.domElement.addEventListener('mouseup', onMouseUp);
            window.addEventListener('resize', onWindowResize, false);




            getNNOutput();//get the output of the neural network
        }

        function drawCubes() { 

            var weight = 1, i;
            var geometry = new THREE.Geometry();
            var pickingGeometry = new THREE.Geometry();
            var pickingMaterial = new THREE.MeshBasicMaterial({ vertexColors: THREE.VertexColors });
            var defaultMaterial = new THREE.MeshLambertMaterial({ color: 0xffffff, shading: THREE.FlatShading, vertexColors: THREE.VertexColors, transparent: true });
            var materials = [];
            for (i = 0; i < nNodes; i++) {
                materials[i] = new THREE.MeshLambertMaterial({ color: 0x00ff00, shading: THREE.FlatShading, transparent: true });
            }
            //*/

            var geom = new THREE.BoxGeometry(9, 9, 9);
            var hideGeom = new THREE.BoxGeometry(1, 1, 1);
            var color = new THREE.Color();

            var matrix = new THREE.Matrix4();
            var quaternion = new THREE.Quaternion();

            for (i = 0; i < nNodes; i++) {


                var position = new THREE.Vector3();
                position.x = posX[i];
                position.y = posY[i];
                position.z = posZ[i];

                var rotation = new THREE.Euler();
                rotation.x = 0;
                rotation.y = 0;
                rotation.z = 0;

                var scale = new THREE.Vector3();
                scale.x = 1;
                scale.y = 1;
                scale.z = 1;


                quaternion.setFromEuler(rotation, false);
                matrix.compose(position, quaternion, scale);

                if (isComputed) {
                    var v = allNodeOutputs[i];
                    var colorNum = math.round(v * 99);
                    r = redLookup[colorNum];
                    g = greenLookup[colorNum];
                    b = blueLookup[colorNum];
                    applyVertexColors(geom, color.setRGB(r, g, b));
                } else {
                    applyVertexColors(geom, color.setRGB(0, 0, 0));
                }

                geometry.merge(geom, matrix);

                // give the geom's vertices a color corresponding to the "id"

                applyVertexColors(geom, color.setHex(i));

                pickingGeometry.merge(geom, matrix);

                pickingData[i] = {
                    position: position,
                    rotation: rotation,
                    scale: scale,
                    id: i
                };

            }

            var drawnObject = new THREE.Mesh(geometry, defaultMaterial);
            drawnObject.name = 'cubes';
            scene.add(drawnObject);

            pickingScene.add(new THREE.Mesh(pickingGeometry, pickingMaterial));
        }


        function adjustRangeOfCubes(geometry, from, to, cubeAdjust) {
            var vertCount = 0;

            geometry.vertices.forEach(function (v) {
                var mod = vertCount % 8;
                var id = math.floor(vertCount / 8) + 1;
                if (id >= from && id <= to) {
                    if (mod == 0) {
                        v.x = v.x - cubeAdjust;
                        v.y = v.y - cubeAdjust;
                        v.z = v.z - cubeAdjust;
                    } else if (mod == 1) {
                        v.x = v.x - cubeAdjust;
                        v.y = v.y - cubeAdjust;
                        v.z = v.z + cubeAdjust;
                    } else if (mod == 2) {
                        v.x = v.x - cubeAdjust;
                        v.y = v.y + cubeAdjust;
                        v.z = v.z - cubeAdjust;
                    } else if (mod == 3) {
                        v.x = v.x - cubeAdjust;
                        v.y = v.y + cubeAdjust;
                        v.z = v.z + cubeAdjust;
                    } else if (mod == 4) {
                        v.x = v.x + cubeAdjust;
                        v.y = v.y - cubeAdjust;
                        v.z = v.z + cubeAdjust;
                    } else if (mod == 5) {
                        v.x = v.x + cubeAdjust;
                        v.y = v.y - cubeAdjust;
                        v.z = v.z - cubeAdjust;
                    } else if (mod == 6) {
                        v.x = v.x + cubeAdjust;
                        v.y = v.y + cubeAdjust;
                        v.z = v.z + cubeAdjust;
                    } else if (mod == 7) {
                        v.x = v.x + cubeAdjust;
                        v.y = v.y + cubeAdjust;
                        v.z = v.z - cubeAdjust;
                    }
                }
                vertCount++;
            });
        }

        function updateCubes() {   
            var r, g, b, i, id;
            var numChildren = scene.children.length;
            for (i = 0; i < numChildren; i++) {
                if (scene.children[i].name == 'cubes') {
                    var object = scene.children[i];
                    var materials = object.material;
                    var geometry = object.geometry;
                    var faceCount = 0;
                    var vertCount = 0;

                    geometry.faces.forEach(function (f) {
                        faceCount++;
                        if (faceCount % 12 == 1) {
                            id = math.floor(faceCount / 12);
                            if (isComputed) {
                                var v = allNodeOutputs[id];
                                var colorNum = math.round(v * 99);
                                r = redLookup[colorNum];
                                g = greenLookup[colorNum];
                                b = blueLookup[colorNum];
                            } else {
                                r = 0; g = 0; b = 0;
                            }
                            color = new THREE.Color();
                            color.setHSL(savedcolor, savedcolor2, v * 0.8);
                        }
                        var n = (f instanceof THREE.Face3) ? 3 : 4;
                        for (var j = 0; j < n; j++) {
                            f.vertexColors[j] = color;

                        }
                    });

                    geometry.colorsNeedUpdate = true;
                    geometry.verticesNeedUpdate = true;
                }
            }
        }

        function drawEdges() { // draw edges between nodes
            //console.log('draw edges');
            var lineMat = new THREE.LineBasicMaterial({
                color: 0x0000ff,
                transparent: true,
                linewidth: 2
            });
            var lineGeom = new THREE.Geometry();
            lineGeom.dynamic = true;
            var line = new THREE.Line(lineGeom, lineMat);
            line.name = 'edges';
            scene.add(line);
        }

        function updateEdges() {   // update edges between nodes
            var r = 1, g = 1, b = 1, rw = 1, gw, bw, i, j, v, colorNum, weight;
            var vertAdjust = 3;
            var numChildren = scene.children.length;
            var colors = [];
            vertCount = 0;
            for (var c = 0; c < numChildren; c++) {
                if (scene.children[c].name == 'edges') {
                    var object = scene.children[c];
                    object.geometry.dispose();

                    var lineGeom = new THREE.Geometry();
                    lineGeom.dynamic = true;

                    if (highlightBox.visible) {
                        ind = interID;
                        if (layerNum[interID] == 0) {
                            // input layer
                        } else if (layerNum[interID] == 1) {
                            // conv1
                            for (j = 1; j <= nPixels; j++) {
                                ind_below = j - 1;
                                temp_below = allNodeNums[ind_below] - 1;
                                var row_below = temp_below % 32;
                                var col_below = math.floor(temp_below / 32);

                                if (row_below > row - 1 && row_below < row + 5 && col_below > col - 1 && col_below < col + 5) {
                                    var ro = row_below - row;
                                    var co = col_below - col;
                                    var weight = conv_nodes[0][filterNum].e(ro + 1, co + 1);

                                    if (input_hide)
                                        vertAdjust = 0;

                                    lineGeom.vertices.push(new THREE.Vector3(posX[ind_below], posY[ind_below] + vertAdjust, posZ[ind_below]));
                                    lineGeom.vertices.push(new THREE.Vector3(posX[ind], posY[ind] - 3, posZ[ind]));

                                    if (isComputed) {
                                        v = allNodeOutputs[ind_below];
                                        colorNum = math.round(v * 99);
                                        r = redLookup[colorNum];
                                        g = greenLookup[colorNum];
                                        b = blueLookup[colorNum];
                                    } else {
                                        r = 0.7;
                                        g = 0.7;
                                        b = 0.7;
                                    }
                                    v = conv_weights_1a[filterNum][ro][co];
                                    colorNum = math.round(v * 99);
                                    rw = 0;
                                    gw = greenLookup[colorNum];
                                    bw = blueLookup[colorNum];

                                    colors[vertCount] = new THREE.Color(rw, gw, bw);
                                colors[vertCount].setHSL(savedcolor, v, 0.5);
                                    vertCount++;
                                    colors[vertCount] = new THREE.Color(rw, gw, bw);
                                colors[vertCount].setHSL(savedcolor, v, 0.5);
                                    vertCount++;
                                }
                            }
                        } else if (layerNum[interID] == 2) {
                            // down1
                            for (j = 1; j <= nConvNodes_1; j++) {
                                ind_below = nPixels + j - 1;
                                temp_below = allNodeNums[ind_below] - 1;
                                filterNum_below = math.floor((ind_below - nPixels) / (28 * 28));
                                var row_below = temp_below % 28;
                                var col_below = math.floor(temp_below / 28);
                                if (filterNum_below == filterNum) {
                                    if (math.floor(row_below / 2) == row && math.floor(col_below / 2) == col) {
                                        var ro = row_below - row;
                                        var co = col_below - col;

                                        if (conv1_hide)
                                            vertAdjust = 0;

                                        lineGeom.vertices.push(new THREE.Vector3(posX[ind_below], posY[ind_below] + vertAdjust, posZ[ind_below]));
                                        lineGeom.vertices.push(new THREE.Vector3(posX[ind], posY[ind] - 3, posZ[ind]));

                                        if (isComputed) {
                                            v = allNodeOutputs[ind_below];
                                            colorNum = math.round(v * 99);
                                            r = redLookup[colorNum];
                                            g = greenLookup[colorNum];
                                            b = blueLookup[colorNum];
                                        } else {
                                            r = 0.7;
                                            g = 0.7;
                                            b = 0.7;
                                        }
                                        v = 1;
                                        colorNum = math.round(v * 99);
                                        rw = 0;
                                        gw = greenLookup[colorNum];     //弃用
                                        bw = blueLookup[colorNum];

                                        colors[vertCount] = new THREE.Color(rw, gw, bw);    // color of edge
                                        colors[vertCount].setHSL(savedcolor, v, 0.5);   //根据背景改变颜色
                                        vertCount++;
                                        colors[vertCount] = new THREE.Color(rw, gw, bw);
                                        colors[vertCount].setHSL(savedcolor, v, 0.5);
                                        vertCount++;
                                    }
                                }
                            }
                        } else if (layerNum[interID] == 3) {
                            // conv2
                            for (j = 1; j <= nConvNodes_1_down; j++) {
                                ind_below = nPixels + nConvNodes_1 + j - 1;
                                temp_below = allNodeNums[ind_below] - 1;
                                filterNum_below = math.floor((ind_below - nPixels - nConvNodes_1) / (14 * 14));
                                var row_below = temp_below % 14;
                                var col_below = math.floor(temp_below / 14);
                                if (keepers.e(filterNum_below + 1, filterNum + 1) == 1) {
                                    if (row_below > row - 1 && row_below < row + 5 && col_below > col - 1 && col_below < col + 5) {
                                        var ro = row_below - row;
                                        var co = col_below - col;
                                        var filterKeeper = keeperIndices[filterNum][filterNum_below];
                                        var weight = conv_nodes[1][filterNum][filterKeeper].e(ro + 1, co + 1);

                                        if (down1_hide)
                                            vertAdjust = 0;

                                        lineGeom.vertices.push(new THREE.Vector3(posX[ind_below], posY[ind_below] + vertAdjust, posZ[ind_below]));
                                        lineGeom.vertices.push(new THREE.Vector3(posX[ind], posY[ind] - 3, posZ[ind]));

                                        if (isComputed) {
                                            v = allNodeOutputs[ind_below];
                                            colorNum = math.round(v * 99);
                                            r = redLookup[colorNum];
                                            g = greenLookup[colorNum];
                                            b = blueLookup[colorNum];
                                        } else {
                                            r = 0.7;
                                            g = 0.7;
                                            b = 0.7;
                                        }
                                        v = conv_weights_2a[filterNum][filterNum_below][ro][co];
                                        colorNum = math.round(v * 99);
                                        rw = 0;
                                        gw = greenLookup[colorNum];
                                        bw = blueLookup[colorNum];

                                        colors[vertCount] = new THREE.Color(rw, gw, bw);
                                colors[vertCount].setHSL(savedcolor, v, 0.5);
                                        vertCount++;
                                        colors[vertCount] = new THREE.Color(rw, gw, bw);
                                colors[vertCount].setHSL(savedcolor, v, 0.5);
                                        vertCount++;
                                    }
                                }
                            }
                        } else if (layerNum[interID] == 4) {
                            // down2
                            for (j = 1; j <= nConvNodes_1; j++) {
                                ind_below = nPixels + nConvNodes_1 + nConvNodes_1_down + j - 1;
                                temp_below = allNodeNums[ind_below] - 1;
                                filterNum_below = math.floor((ind_below - nPixels - nConvNodes_1 - nConvNodes_1_down) / (10 * 10));
                                var row_below = temp_below % 10;
                                var col_below = math.floor(temp_below / 10);
                                if (filterNum_below == filterNum) {
                                    if (math.floor(row_below / 2) == row && math.floor(col_below / 2) == col) {
                                        var ro = row_below - row;
                                        var co = col_below - col;

                                        if (conv2_hide)
                                            vertAdjust = 0;

                                        lineGeom.vertices.push(new THREE.Vector3(posX[ind_below], posY[ind_below] + vertAdjust, posZ[ind_below]));
                                        lineGeom.vertices.push(new THREE.Vector3(posX[ind], posY[ind] - 3, posZ[ind]));

                                        if (isComputed) {
                                            v = allNodeOutputs[ind_below];
                                            colorNum = math.round(v * 99);
                                            r = redLookup[colorNum];
                                            g = greenLookup[colorNum];
                                            b = blueLookup[colorNum];
                                        } else {
                                            r = 0.7;
                                            g = 0.7;
                                            b = 0.7;
                                        }
                                        v = 1;
                                        colorNum = math.round(v * 99);
                                        rw = 0;
                                        gw = greenLookup[colorNum];
                                        bw = blueLookup[colorNum];

                                        colors[vertCount] = new THREE.Color(rw, gw, bw);
                                colors[vertCount].setHSL(savedcolor, v, 0.5);
                                        vertCount++;
                                        colors[vertCount] = new THREE.Color(rw, gw, bw);
                                colors[vertCount].setHSL(savedcolor, v, 0.5);
                                        vertCount++;
                                    }
                                }
                            }
                        } else if (layerNum[interID] == 5) {
                            // hidden layer 1
                            for (j = 1; j <= nConvNodes_2_down; j++) {

                                ind_below = nPixels + nConvNodes_1 + nConvNodes_1_down + nConvNodes_2 + j - 1;
                                var weight = hidden_weights_1.e(allNodeNums[ind], allNodeNums[ind_below]);

                                if (down2_hide)
                                    vertAdjust = 0;

                                lineGeom.vertices.push(new THREE.Vector3(posX[ind_below], posY[ind_below] + vertAdjust, posZ[ind_below]));
                                lineGeom.vertices.push(new THREE.Vector3(posX[ind], posY[ind] - 3, posZ[ind]));

                                if (isComputed) {
                                    v = allNodeOutputs[ind_below];
                                    colorNum = math.round(v * 99);
                                    r = redLookup[colorNum];
                                    g = greenLookup[colorNum];
                                    b = blueLookup[colorNum];
                                } else {
                                    r = 0.7;
                                    g = 0.7;
                                    b = 0.7;
                                }
                                v = hidden_weights_1a[allNodeNums[ind] - 1][allNodeNums[ind_below] - 1];
                                colorNum = math.round(v * 99);
                                rw = 0;
                                gw = greenLookup[colorNum];
                                bw = blueLookup[colorNum];

                                colors[vertCount] = new THREE.Color(rw, gw, bw);
                                colors[vertCount].setHSL(savedcolor, v, 0.5);
                                vertCount++;
                                colors[vertCount] = new THREE.Color(rw, gw, bw);
                                colors[vertCount].setHSL(savedcolor, v, 0.5);
                                vertCount++;
                            }
                        } else if (layerNum[interID] == 6) {
                            // hidden layer 2
                            for (j = 1; j <= nHiddenNodes_1; j++) {
                                ind_below = nPixels + nConvNodes_1 + nConvNodes_1_down + nConvNodes_2 + nConvNodes_2_down + j - 1;
                                var weight = hidden_weights_2.e(allNodeNums[ind], allNodeNums[ind_below]);

                                if (fc1_hide)
                                    vertAdjust = 0;

                                lineGeom.vertices.push(new THREE.Vector3(posX[ind_below], posY[ind_below] + vertAdjust, posZ[ind_below]));
                                lineGeom.vertices.push(new THREE.Vector3(posX[ind], posY[ind] - 3, posZ[ind]));
                                if (isComputed) {
                                    v = allNodeOutputs[ind_below];
                                    colorNum = math.round(v * 99);
                                    r = redLookup[colorNum];
                                    g = greenLookup[colorNum];
                                    b = blueLookup[colorNum];
                                } else {
                                    r = 0.7;
                                    g = 0.7;
                                    b = 0.7;
                                }
                                v = hidden_weights_2a[allNodeNums[ind] - 1][allNodeNums[ind_below] - 1];
                                colorNum = math.round(v * 99);
                                rw = 0;
                                gw = greenLookup[colorNum];
                                bw = blueLookup[colorNum];

                                colors[vertCount] = new THREE.Color(rw, gw, bw);
                                colors[vertCount].setHSL(savedcolor, v, 0.5);
                                
                                vertCount++;
                                colors[vertCount] = new THREE.Color(rw, gw, bw);
                                colors[vertCount].setHSL(savedcolor, v, 0.5);
                            
                                vertCount++;
                            }
                        } else if (layerNum[interID] == 7) {
                            // Output layer
                            for (j = 1; j <= nHiddenNodes_2; j++) {
                                ind_below = nPixels + nConvNodes_1 + nConvNodes_1_down + nConvNodes_2 + nConvNodes_2_down + nHiddenNodes_1 + j - 1;
                                var weight = final_weights.e(allNodeNums[ind], allNodeNums[ind_below]);

                                if (fc2_hide)
                                    vertAdjust = 0;

                                lineGeom.vertices.push(new THREE.Vector3(posX[ind_below], posY[ind_below] + vertAdjust, posZ[ind_below]));
                                lineGeom.vertices.push(new THREE.Vector3(posX[ind], posY[ind] - 3, posZ[ind]));
                                if (isComputed) {
                                    v = allNodeOutputs[ind_below];
                                    colorNum = math.round(v * 99);
                                    r = redLookup[colorNum];
                                    g = greenLookup[colorNum];
                                    b = blueLookup[colorNum];
                                } else {
                                    r = 0.7;
                                    g = 0.7;
                                    b = 0.7;
                                }
                                v = final_weightsa[allNodeNums[ind] - 1][allNodeNums[ind_below] - 1];
                                colorNum = math.round(v * 99);
                                rw = 0;
                                gw = greenLookup[colorNum];
                                bw = blueLookup[colorNum];

                                colors[vertCount] = new THREE.Color(rw, gw, bw);
                                colors[vertCount].setHSL(savedcolor, v, 0.5);
                                vertCount++;
                                colors[vertCount] = new THREE.Color(rw, gw, bw);
                                colors[vertCount].setHSL(savedcolor, v, 0.5);
                                vertCount++;
                            }
                        }
                        v = allNodeOutputs[ind];
                        colorNum = math.round(v * 99);
                        r = redLookup[colorNum];
                        g = greenLookup[colorNum];
                        b = blueLookup[colorNum];

                    }
                    var lineMat = new THREE.LineBasicMaterial({ color: 0xffffff, opacity: 1, linewidth: 1, vertexColors: THREE.VertexColors });
                    object.material = lineMat;
                    object.geometry.colors = colors;
                    object.geometry.vertices = lineGeom.vertices;
                    object.material.needsUpdate = true;
                    object.geometry.colorsNeedUpdate = true;
                    object.geometry.verticesNeedUpdate = true;
                    break;
                }
            }
        }

        function onWindowResize(e) {//adjust the camera when the window is resized
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            render();
        }

        function onMouseDown(e) {
            rotatingCam = true;
            infobox.style.visibility = "hidden";
        }

        function onClick(e) {
        }

        function onMouseUp(e) {
            rotatingCam = false;

            var infobox = document.getElementById("infobox");   //弃用
            if (intersected) {
                if (infobox.style.visibility == "visible")
                    infobox.style.visibility = "hidden";
                else
                    infobox.style.visibility = "visible";

            } else {
                infobox.style.visibility = "hidden";
            }
        }

        function onMouseMove(e) {
            var newWidth = window.innerWidth;
            var newHeight = window.innerHeight;
            var widthCoeff = originalWidth / newWidth;
            var heightCoeff = originalHeight / newHeight;
            mouse.x = math.round(e.clientX * widthCoeff);
            mouse.y = math.round(e.clientY * heightCoeff);

            mousepx.x = e.clientX;
            mousepx.y = e.clientY;

        }

        function animate() {

            requestAnimationFrame(animate);
            render();
            

        }

        function pick() {

            //render the picking scene off-screen

            renderer.render(pickingScene, camera, pickingTexture);

            //create buffer for reading single pixel
            var pixelBuffer = new Uint8Array(4);

            //read the pixel under the mouse from the texture
            renderer.readRenderTargetPixels(pickingTexture, mouse.x, pickingTexture.height - mouse.y, 1, 1, pixelBuffer);

            //interpret the pixel as an ID

            var id = (pixelBuffer[0] << 16) | (pixelBuffer[1] << 8) | (pixelBuffer[2]);
            var data = pickingData[id];

            if (data && pixelBuffer[3]) {
                var temp = pickingData[id].id;
                if (!((input_hide && temp < nPixels) ||
                    (conv1_hide && temp >= nPixels && temp < nPixels + nConvNodes_1) ||
                    (down1_hide && temp >= nPixels + nConvNodes_1 && temp < nPixels + nConvNodes_1 + nConvNodes_1_down) ||
                    (conv2_hide && temp >= nPixels + nConvNodes_1 + nConvNodes_1_down && temp < nPixels + nConvNodes_1 + nConvNodes_1_down + nConvNodes_2) ||
                    (down2_hide && temp >= nPixels + nConvNodes_1 + nConvNodes_1_down + nConvNodes_2 && temp < nPixels + nConvNodes_1 + nConvNodes_1_down + nConvNodes_2 + nConvNodes_2_down) ||
                    (fc1_hide && temp >= nPixels + nConvNodes_1 + nConvNodes_1_down + nConvNodes_2 + nConvNodes_2_down && temp < nPixels + nConvNodes_1 + nConvNodes_1_down + nConvNodes_2 + nConvNodes_2_down + nHiddenNodes_1) ||
                    (fc2_hide && temp >= nPixels + nConvNodes_1 + nConvNodes_1_down + nConvNodes_2 + nConvNodes_2_down + nHiddenNodes_1 && temp < nPixels + nConvNodes_1 + nConvNodes_1_down + nConvNodes_2 + nConvNodes_2_down + nHiddenNodes_1 + nHiddenNodes_2) ||
                    (output_hide && temp >= nPixels + nConvNodes_1 + nConvNodes_1_down + nConvNodes_2 + nConvNodes_2_down + nHiddenNodes_1 + nHiddenNodes_2 && temp < nPixels + nConvNodes_1 + nConvNodes_1_down + nConvNodes_2 + nConvNodes_2_down + nHiddenNodes_1 + nHiddenNodes_2 + nFinalNodes))) {

                    interID = pickingData[id].id;


                    if (layerNum[interID] == 0) {
                        nodeType = "Input layer";
                        filterNum = -1;
                        tempInd = allNodeNums[interID] - 1;
                        row = (tempInd) % 32;
                        col = math.floor(tempInd / 32);
                    } else if (layerNum[interID] == 1) {
                        nodeType = "Convolution layer 1";
                        filterNum = math.floor((interID - nPixels) / (28 * 28));
                        tempInd = allNodeNums[interID] - 1;
                        row = (tempInd) % 28;
                        col = math.floor(tempInd / 28);
                    } else if (layerNum[interID] == 2) {
                        nodeType = "Downsampling layer 1";
                        filterNum = math.floor((interID - nPixels - nConvNodes_1) / (14 * 14));
                        tempInd = allNodeNums[interID] - 1;
                        row = (tempInd) % 14;
                        col = math.floor(tempInd / 14);
                    } else if (layerNum[interID] == 3) {
                        nodeType = "Convolution layer 2";
                        filterNum = math.floor((interID - nPixels - nConvNodes_1 - nConvNodes_1_down) / (10 * 10));
                        tempInd = allNodeNums[interID] - 1;
                        row = (tempInd) % 10;
                        col = math.floor(tempInd / 10);
                    } else if (layerNum[interID] == 4) {
                        nodeType = "Downsampling layer 2";
                        filterNum = math.floor((interID - nPixels - nConvNodes_1 - nConvNodes_1_down - nConvNodes_2) / (5 * 5));
                        tempInd = allNodeNums[interID] - 1;
                        row = (tempInd) % 5;
                        col = math.floor(tempInd / 5);
                    } else if (layerNum[interID] == 5) {
                        nodeType = "Fully-connected layer 1";
                        filterNum = -1
                    } else if (layerNum[interID] == 6) {
                        nodeType = "Fully-connected layer 2";
                        filterNum = -1
                    } else if (layerNum[interID] == 7) {
                        nodeType = "Output layer";
                        filterNum = -1
                    }

                    //move our highlightBox so that it surrounds the picked object
                    if (data.position && data.rotation && data.scale) {
                        highlightBox.position.copy(data.position);
                        highlightBox.rotation.copy(data.rotation);
                        highlightBox.visible = true;
                        intersected = true;
                    }
                }
            } else {
                highlightBox.visible = false;
                intersected = false;
            }
            if (highlightBox.visible == true) {
                var r, g, b;
                if (isComputed) {
                    var v = allNodeOutputs[interID];
                    var colorNum = math.round(v * 99);
                    r = redLookup[colorNum];
                    g = greenLookup[colorNum];
                    b = blueLookup[colorNum];
                } else {
                    r = 0, g = 0, b = 0;
                }
                highlightBox.material.color.setRGB(r, g, b);
                highlightBox.material.needsUpdate = true;
            }


        }

        function render() {

            if (!rotatingCam) {
                pick();
                updateEdges();
                updateCubes();
            }

            document.getElementById("infobox").style.visibility = "hidden";


            renderer.render(scene, camera);

        }

        function loadData() {   //加载模型位置、名称数据
            var nodeCount = 0;
            $.getJSON('./js/nn/webgl_convnet2.json', function (data) {
                $.each(data.nodes, function (i, node) {
                    posX[nodeCount] = node.x;
                    posY[nodeCount] = node.y;
                    posZ[nodeCount] = node.z;
                    layerNum[nodeCount] = node.layerNum;
                    nodeCount++;
                });
            }).error(function () {
                console.log('error');
            }).done(function () {
                setupWeightArrays();
                createText(nums, 0, 100);
                drawCubes();
                drawEdges();
                uncheckAll();
            });
        }



        function uncheckAll() {
            var w = document.getElementsByTagName('input');
            for (var i = 0; i < w.length; i++) {
                if (w[i].type == 'checkbox') {
                    w[i].checked = false;
                }
            }
        }

    </script>
</body>
<script>
    (function (i, s, o, g, r, a, m) {
        i['GoogleAnalyticsObject'] = r; i[r] = i[r] || function () {
            (i[r].q = i[r].q || []).push(arguments)
        }, i[r].l = 1 * new Date(); a = s.createElement(o),
            m = s.getElementsByTagName(o)[0]; a.async = 1; a.src = g; m.parentNode.insertBefore(a, m)
    })(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');

    ga('create', 'UA-61302010-1', 'auto');
    ga('send', 'pageview');

</script>

</html>